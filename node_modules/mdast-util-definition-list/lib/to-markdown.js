const defListHandler = (node, _parent, state, info) => {
    const exit = state.enter('defList');
    const value = state.containerFlow(node, info);
    exit();
    return value;
};
const defListTermHandler = (node, _parent, state, info) => {
    const exit = state.enter('defListTerm');
    const subexit = state.enter('phrasing');
    // @ts-ignore -- cannot extend phrasingParents
    const value = state.containerPhrasing(node, { ...info, before: '\n', after: '\n' });
    subexit();
    exit();
    return value;
};
const defListDescriptionHandler = (node, _parent, state, info) => {
    const exit = state.enter('defListDescription');
    const value = state.indentLines(state.containerFlow(node, info), map);
    exit();
    return value;
    function map(line, index, blank) {
        if (index) {
            return blank ? '' : ' '.repeat(4) + line;
        }
        return blank ? ':' + ' '.repeat(3) : ':' + ' '.repeat(3) + line;
    }
};
const joinDefItems = (left, right, parent, _state) => {
    if (parent.type !== 'defList') {
        return;
    }
    // @ts-ignore - cannot extend FlowChildren type
    if (left.type === 'defListDescription' && right.type === 'defListTerm') {
        return 1;
    }
    return 'spread' in right && right.spread ? 1 : 0;
};
export const defListToMarkdown = {
    join: [joinDefItems],
    unsafe: [{ character: ':', atBreak: true, after: '(?:[ \t\r\n])' }],
    handlers: {
        defList: defListHandler,
        defListTerm: defListTermHandler,
        defListDescription: defListDescriptionHandler,
    },
};
